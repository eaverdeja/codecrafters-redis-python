from time import time
from collections import defaultdict, OrderedDict
from dataclasses import dataclass
from typing import Self

from .utils import Container


class StreamError(Exception):
    pass


Attributes = dict[str, str]
Stream = OrderedDict[str, Attributes]


@dataclass
class EntryId:
    time: int
    sequence: int

    @classmethod
    def parse(cls, entry_id: str):
        """
        Parse an entry ID for a stream, in the format {time}-{sequence}.
        A single "*" is used when fully auto-generating IDs.
        Uses -1 to represent auto-generated times and sequences (*).
        """
        if entry_id == "*":
            return cls(time=-1, sequence=-1)
        time_str, sequence_str = entry_id.split("-")
        time_int = int(time_str)
        sequence = int(sequence_str) if sequence_str != "*" else -1
        return cls(time=time_int, sequence=sequence)

    def __str__(self):
        return f"{self.time}-{self.sequence}"

    @property
    def has_autogenerated_time(self) -> bool:
        return self.time == -1

    @property
    def has_autogenerated_sequence(self) -> bool:
        return self.sequence == -1

    @staticmethod
    def validate_entry_id(new_id: Self, top_id: Self | None):
        if new_id.time == 0 and new_id.sequence == 0:
            raise StreamError("The ID specified in XADD must be greater than 0-0")
        if top_id:
            if new_id.time < top_id.time:
                raise StreamError(
                    "The ID specified in XADD is equal or smaller than the target stream top item"
                )
            elif new_id.time == top_id.time and new_id.sequence <= top_id.sequence:
                raise StreamError(
                    "The ID specified in XADD is equal or smaller than the target stream top item"
                )

    @staticmethod
    def generate_time(new_id: Self, top_id: Self | None) -> int:
        # Time should be in milliseconds
        now = int(time() * 10e2)
        if not top_id:
            return now
        if new_id.time == top_id.time:
            return top_id.time + 1
        return now

    @staticmethod
    def generate_sequence(new_id: Self, top_id: Self | None) -> int:
        if not top_id:
            return 0 if new_id.time > 0 else 1
        if new_id.time == top_id.time:
            return top_id.sequence + 1
        return 0


class Datastore(dict):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._streams: dict[str, Stream] = defaultdict(OrderedDict)

    def __getitem__(self, key):
        try:
            item = super().__getitem__(key)
        except KeyError:
            return None

        if item.expiry and time() > item.expiry:
            del self[key]
            return None
        return item.value

    def __setitem__(self, key, value):
        if not isinstance(value, Container):
            value = Container(value=value)
        return super().__setitem__(key, value)

    def add_to_stream(self, key: str, entry_id: str, attributes: dict[str, str]):
        new_id = EntryId.parse(entry_id)
        top_entry = self.peek(key)
        top_id = EntryId.parse(top_entry) if top_entry else None

        if new_id.has_autogenerated_time:
            new_id.time = EntryId.generate_time(new_id, top_id)
        if new_id.has_autogenerated_sequence:
            new_id.sequence = EntryId.generate_sequence(new_id, top_id)

        EntryId.validate_entry_id(new_id, top_id)

        new_entry_id = str(new_id)
        self._streams[key][new_entry_id] = attributes
        return new_entry_id

    def peek(self, key: str):
        """
        Returns the key of the most recent entry on the stream.
        Returns none if no entries exist in the stream.
        """
        stream = self._streams[key]
        try:
            return next(reversed(stream))
        except StopIteration:
            return None
