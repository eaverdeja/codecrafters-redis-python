from time import time
from collections import defaultdict, OrderedDict
from dataclasses import dataclass
from typing import Self
from sys import maxsize

from .utils import Container


class StreamError(Exception):
    pass


Attributes = dict[str, str]
Stream = OrderedDict[str, Attributes]


@dataclass
class EntryId:
    time: int
    sequence: int

    @classmethod
    def parse(cls, entry_id: str, top_entry: Self | None = None):
        """
        Parse an entry ID for a stream, in the format {time}-{sequence}.
        A single "*" is used when fully auto-generating IDs.
        Uses -1 to represent auto-generated times and sequences (*).
        Uses -sys.maxsize and sys.maxsize to represent
        start (-) and end (+) query params, respectively.
        ($) as a start position will replicate the top entry's information.
        """
        if entry_id == "*":
            return cls(time=-1, sequence=-1)
        if entry_id == "-":
            return cls(time=-maxsize, sequence=0)
        if entry_id == "+":
            return cls(time=maxsize, sequence=0)
        if entry_id == "$":
            if not top_entry:
                raise StreamError(
                    "Expected top_entry to be supplied when parsing $ for XREAD"
                )
            return cls(time=top_entry.time, sequence=top_entry.sequence)

        time_str, sequence_str = entry_id.split("-")
        time_int = int(time_str)
        sequence = int(sequence_str) if sequence_str != "*" else -1
        return cls(time=time_int, sequence=sequence)

    def __str__(self):
        return f"{self.time}-{self.sequence}"

    def __eq__(self, other):
        if not isinstance(other, EntryId):
            raise NotImplemented
        return self.time == other.time and self.sequence == other.sequence

    def __lt__(self, other):
        if not isinstance(other, EntryId):
            raise NotImplemented
        if self.time == other.time:
            return self.sequence < other.sequence
        return self.time < other.time

    def __le__(self, other):
        if not isinstance(other, EntryId):
            raise NotImplemented
        if self.time == other.time:
            return self.sequence <= other.sequence
        return self.time <= other.time

    def __gt__(self, other):
        if not isinstance(other, EntryId):
            raise NotImplemented
        if self.time == other.time:
            return self.sequence > other.sequence
        return self.time > other.time

    def __ge__(self, other):
        if not isinstance(other, EntryId):
            raise NotImplemented
        if self.time == other.time:
            return self.sequence >= other.sequence
        return self.time >= other.time

    @property
    def has_autogenerated_time(self) -> bool:
        return self.time == -1

    @property
    def has_autogenerated_sequence(self) -> bool:
        return self.sequence == -1

    @staticmethod
    def validate_entry_id(new_id: Self, top_id: Self | None):
        if new_id.time == 0 and new_id.sequence == 0:
            raise StreamError("The ID specified in XADD must be greater than 0-0")
        if top_id:
            if new_id.time < top_id.time:
                raise StreamError(
                    "The ID specified in XADD is equal or smaller than the target stream top item"
                )
            elif new_id.time == top_id.time and new_id.sequence <= top_id.sequence:
                raise StreamError(
                    "The ID specified in XADD is equal or smaller than the target stream top item"
                )

    @staticmethod
    def generate_time(new_id: Self, top_id: Self | None) -> int:
        # Time should be in milliseconds
        now = int(time() * 10e2)
        if not top_id:
            return now
        if new_id.time == top_id.time:
            return top_id.time + 1
        return now

    @staticmethod
    def generate_sequence(new_id: Self, top_id: Self | None) -> int:
        if not top_id:
            return 0 if new_id.time > 0 else 1
        if new_id.time == top_id.time:
            return top_id.sequence + 1
        return 0


@dataclass
class StreamEntry:
    entry_id: EntryId
    attributes: Attributes


class Datastore(dict):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._streams: dict[str, Stream] = defaultdict(OrderedDict)

    def __getitem__(self, key):
        try:
            item = super().__getitem__(key)
        except KeyError:
            return None

        if item.expiry and time() > item.expiry:
            del self[key]
            return None
        return item.value

    def __setitem__(self, key, value):
        if not isinstance(value, Container):
            value = Container(value=value)
        return super().__setitem__(key, value)

    def add_to_stream(self, key: str, entry_id: str, attributes: dict[str, str]):
        new_id = EntryId.parse(entry_id)
        top_entry = self.peek(key)
        top_id = EntryId.parse(top_entry) if top_entry else None

        if new_id.has_autogenerated_time:
            new_id.time = EntryId.generate_time(new_id, top_id)
        if new_id.has_autogenerated_sequence:
            new_id.sequence = EntryId.generate_sequence(new_id, top_id)

        EntryId.validate_entry_id(new_id, top_id)

        new_entry_id = str(new_id)
        self._streams[key][new_entry_id] = attributes
        return new_entry_id

    def peek(self, key: str):
        """
        Returns the key of the most recent entry on the stream.
        Returns none if no entries exist in the stream.
        """
        stream = self._streams[key]
        try:
            return next(reversed(stream))
        except StopIteration:
            return None

    def query_from_stream(
        self,
        key: str,
        start: str,
        end: str | None = None,
        inclusive: bool = True,
        top_entry: EntryId | None = None,
    ) -> list[StreamEntry]:
        start_entry_id = EntryId.parse(start, top_entry=top_entry)

        entries = []
        for entry_id, attributes in self._streams[key].items():
            parsed_entry_id = EntryId.parse(entry_id)

            # Check if entry is out of bounds
            if inclusive and parsed_entry_id == start_entry_id:
                pass
            elif parsed_entry_id <= start_entry_id:
                continue
            if end is not None and parsed_entry_id > EntryId.parse(end):
                continue

            entries.append(StreamEntry(entry_id=entry_id, attributes=attributes))
        return entries
